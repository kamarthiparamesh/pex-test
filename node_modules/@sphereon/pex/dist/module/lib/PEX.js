import { CredentialMapper, } from '@sphereon/ssi-types';
import { Status } from './ConstraintUtils';
import { EvaluationClientWrapper } from './evaluation';
import { PresentationSubmissionLocation, } from './signing';
import { PEVersion, SSITypesBuilder } from './types';
import { definitionVersionDiscovery, getSubjectIdsAsString } from './utils';
import { PresentationDefinitionV1VB, PresentationDefinitionV2VB, PresentationSubmissionVB, ValidationEngine } from './validation';
/**
 * This is the main interfacing class to be used by developers using the PEX library.
 */
export class PEX {
    _evaluationClientWrapper;
    constructor() {
        // TODO:  So we have state in the form of this property which is set in the constructor, but we are overwriting it elsewhere. We need to retrhink how to instantiate PEX
        this._evaluationClientWrapper = new EvaluationClientWrapper();
    }
    /***
     * The evaluatePresentation compares what is expected from a presentation with a presentationDefinition.
     * presentationDefinition: It can be either v1 or v2 of presentationDefinition
     *
     * @param presentationDefinition the definition of what is expected in the presentation.
     * @param presentation the presentation which has to be evaluated in comparison of the definition.
     * @param opts - limitDisclosureSignatureSuites the credential signature suites that support limit disclosure
     *
     * @return the evaluation results specify what was expected and was fulfilled and also specifies which requirements described in the input descriptors
     * were not fulfilled by the presentation.
     */
    evaluatePresentation(presentationDefinition, presentation, opts) {
        const generatePresentationSubmission = opts?.generatePresentationSubmission !== undefined ? opts.generatePresentationSubmission : opts?.presentationSubmission === undefined;
        const pd = SSITypesBuilder.toInternalPresentationDefinition(presentationDefinition);
        const presentationCopy = JSON.parse(JSON.stringify(presentation));
        const wrappedPresentation = SSITypesBuilder.mapExternalVerifiablePresentationToWrappedVP(presentationCopy);
        const presentationSubmission = opts?.presentationSubmission ?? wrappedPresentation.decoded.presentation_submission;
        if (!presentationSubmission && !generatePresentationSubmission) {
            throw Error(`Either a presentation submission as part of the VP or provided separately was expected`);
        }
        const holderDIDs = wrappedPresentation.presentation.holder ? [wrappedPresentation.presentation.holder] : [];
        const updatedOpts = {
            ...opts,
            holderDIDs,
            presentationSubmission,
            generatePresentationSubmission,
        };
        const result = this._evaluationClientWrapper.evaluate(pd, wrappedPresentation.vcs, updatedOpts);
        if (result.value?.descriptor_map.length) {
            const selectFromClientWrapper = new EvaluationClientWrapper();
            const selectResults = selectFromClientWrapper.selectFrom(pd, wrappedPresentation.vcs, updatedOpts);
            if (selectResults.areRequiredCredentialsPresent !== Status.ERROR) {
                result.errors = [];
            }
        }
        return result;
    }
    /***
     * The evaluate compares what is expected from a verifiableCredentials with the presentationDefinition.
     *
     * @param presentationDefinition the v1 or v2 definition of what is expected in the presentation.
     * @param verifiableCredentials the verifiable credentials which are candidates to fulfill requirements defined in the presentationDefinition param.
     * @param opts - holderDIDs the list of the DIDs that the wallet holders controls. Optional, but needed by some input requirements that do a holderDID check.
     * @           - limitDisclosureSignatureSuites the credential signature suites that support limit disclosure
     *
     * @return the evaluation results specify what was expected and was fulfilled and also specifies which requirements described in the input descriptors
     * were not fulfilled by the verifiable credentials.
     */
    evaluateCredentials(presentationDefinition, verifiableCredentials, opts) {
        const wrappedVerifiableCredentials = SSITypesBuilder.mapExternalVerifiableCredentialsToWrappedVcs(verifiableCredentials);
        // TODO:  So we have state in the form of this property which is set in the constructor, but we are overwriting it here. We need to retrhink how to instantiate PEX
        this._evaluationClientWrapper = new EvaluationClientWrapper();
        const pd = SSITypesBuilder.toInternalPresentationDefinition(presentationDefinition);
        const result = this._evaluationClientWrapper.evaluate(pd, wrappedVerifiableCredentials, opts);
        if (result.value && result.value.descriptor_map.length) {
            const selectFromClientWrapper = new EvaluationClientWrapper();
            const selectResults = selectFromClientWrapper.selectFrom(pd, wrappedVerifiableCredentials, opts);
            result.areRequiredCredentialsPresent = selectResults.areRequiredCredentialsPresent;
            result.errors = selectResults.errors;
        }
        else {
            result.areRequiredCredentialsPresent = Status.ERROR;
        }
        return result;
    }
    /**
     * The selectFrom method is a helper function that helps filter out the verifiable credentials which can not be selected and returns
     * the selectable credentials.
     *
     * @param presentationDefinition the v1 or v2 definition of what is expected in the presentation.
     * @param verifiableCredentials verifiable credentials are the credentials from wallet provided to the library to find selectable credentials.
     * @param opts - holderDIDs the decentralized identifier(s) of the wallet holderDID. This is used to identify the credentials issued to the holderDID of wallet in certain scenario's.
     *             - limitDisclosureSignatureSuites the credential signature suites that support limit disclosure
     *
     * @return the selectable credentials.
     */
    selectFrom(presentationDefinition, verifiableCredentials, opts) {
        const verifiableCredentialCopy = JSON.parse(JSON.stringify(verifiableCredentials));
        const pd = SSITypesBuilder.toInternalPresentationDefinition(presentationDefinition);
        // TODO:  So we have state in the form of this property which is set in the constructor, but we are overwriting it here. We need to retrhink how to instantiate PEX
        this._evaluationClientWrapper = new EvaluationClientWrapper();
        return this._evaluationClientWrapper.selectFrom(pd, SSITypesBuilder.mapExternalVerifiableCredentialsToWrappedVcs(verifiableCredentialCopy), opts);
    }
    presentationSubmissionFrom(presentationDefinition, selectedCredentials, opts) {
        const pd = SSITypesBuilder.toInternalPresentationDefinition(presentationDefinition);
        return this._evaluationClientWrapper.submissionFrom(pd, SSITypesBuilder.mapExternalVerifiableCredentialsToWrappedVcs(selectedCredentials), opts);
    }
    /**
     * This method helps create an Unsigned Presentation. An Unsigned Presentation after signing becomes a Presentation. And can be sent to
     * the verifier after signing it.
     *
     * @param presentationDefinition the v1 or v2 definition of what is expected in the presentation.
     * @param selectedCredentials the credentials which were declared selectable by getSelectableCredentials and then chosen by the intelligent-user
     * (e.g. human).
     * @param opts - holderDID optional; the decentralized identity of the wallet holderDID. This is used to identify the holderDID of the presentation.
     *
     * @return the presentation.
     */
    presentationFrom(presentationDefinition, selectedCredentials, opts) {
        const presentationSubmissionLocation = opts?.presentationSubmissionLocation ?? PresentationSubmissionLocation.PRESENTATION;
        const presentationSubmission = this.presentationSubmissionFrom(presentationDefinition, selectedCredentials, opts);
        const presentation = PEX.constructPresentation(selectedCredentials, {
            ...opts,
            // We only pass in the submission in case it needs to be included in the presentation
            presentationSubmission: presentationSubmissionLocation === PresentationSubmissionLocation.PRESENTATION ? presentationSubmission : undefined,
        });
        return {
            presentation,
            presentationSubmissionLocation,
            presentationSubmission,
        };
    }
    static constructPresentation(selectedCredentials, opts) {
        if (!selectedCredentials) {
            throw Error(`At least a verifiable credential needs to be passed in to create a presentation`);
        }
        const verifiableCredential = (Array.isArray(selectedCredentials) ? selectedCredentials : [selectedCredentials]);
        const wVCs = verifiableCredential.map((vc) => CredentialMapper.toWrappedVerifiableCredential(vc));
        const holders = Array.from(new Set(wVCs.flatMap((wvc) => getSubjectIdsAsString(wvc.credential))));
        if (holders.length !== 1 && !opts?.holderDID) {
            console.log(`We deduced ${holders.length} subject from ${wVCs.length} Verifiable Credentials, and no holder property was given. This might lead to undesired results`);
        }
        const holder = opts?.holderDID ?? (holders.length === 1 ? holders[0] : undefined);
        const type = opts?.basePresentationPayload?.type
            ? Array.isArray(opts.basePresentationPayload.type)
                ? opts.basePresentationPayload.type
                : [opts.basePresentationPayload.type]
            : [];
        if (!type.includes('VerifiablePresentation')) {
            type.push('VerifiablePresentation');
        }
        const context = opts?.basePresentationPayload?.['@context']
            ? Array.isArray(opts.basePresentationPayload['@context'])
                ? opts.basePresentationPayload['@context']
                : [opts.basePresentationPayload['@context']]
            : [];
        if (!context.includes('https://www.w3.org/2018/credentials/v1')) {
            context.push('https://www.w3.org/2018/credentials/v1');
        }
        if (opts?.presentationSubmission) {
            if (!type.includes('PresentationSubmission')) {
                type.push('PresentationSubmission');
            }
            if (!context.includes('https://identity.foundation/presentation-exchange/submission/v1')) {
                context.push('https://identity.foundation/presentation-exchange/submission/v1');
            }
        }
        return {
            ...opts?.basePresentationPayload,
            '@context': context,
            type,
            holder,
            ...(opts?.presentationSubmission && { presentation_submission: opts.presentationSubmission }),
            verifiableCredential
        };
    }
    /**
     * This method validates whether an object is usable as a presentation definition or not.
     *
     * @param presentationDefinition presentationDefinition of V1 or v2 to be validated.
     *
     * @return the validation results to reveal what is acceptable/unacceptable about the passed object to be considered a valid presentation definition
     */
    static validateDefinition(presentationDefinition) {
        const result = definitionVersionDiscovery(presentationDefinition);
        if (result.error) {
            throw new Error(result.error);
        }
        const validators = [];
        result.version === PEVersion.v1
            ? validators.push({
                bundler: new PresentationDefinitionV1VB('root'),
                target: SSITypesBuilder.modelEntityToInternalPresentationDefinitionV1(presentationDefinition),
            })
            : validators.push({
                bundler: new PresentationDefinitionV2VB('root'),
                target: SSITypesBuilder.modelEntityInternalPresentationDefinitionV2(presentationDefinition),
            });
        return new ValidationEngine().validate(validators);
    }
    /**
     * This method validates whether an object is usable as a presentation submission or not.
     *
     * @param presentationSubmission the object to be validated.
     *
     * @return the validation results to reveal what is acceptable/unacceptable about the passed object to be considered a valid presentation submission
     */
    static validateSubmission(presentationSubmission) {
        return new ValidationEngine().validate([
            {
                bundler: new PresentationSubmissionVB('root'),
                target: presentationSubmission,
            },
        ]);
    }
    /**
     * This method can be used to combine a definition, selected Verifiable Credentials, together with
     * signing opts and a callback to sign a presentation, making it a Verifiable Presentation before sending.
     *
     * Please note that PEX has no signature support on purpose. We didn't want this library to depend on all kinds of signature suites.
     * The callback function next to the Signing Params also gets a Presentation which is evaluated against the definition.
     * It is up to you to decide whether you simply update the supplied partial proof and add it to the presentation in the callback,
     * or whether you will use the selected Credentials, Presentation definition, evaluation results and/or presentation submission together with the signature opts
     *
     * @param presentationDefinition the Presentation Definition V1 or V2
     * @param selectedCredentials the PEX and/or User selected/filtered credentials that will become part of the Verifiable Presentation
     * @param signingCallBack the function which will be provided as a parameter. And this will be the method that will be able to perform actual
     *        signing. One example of signing is available in the project named. pe-selective-disclosure.
     * @param opts Signing Params these are the signing params required to sign.
     *
     * @return the signed and thus Verifiable Presentation.
     */
    async verifiablePresentationFrom(presentationDefinition, selectedCredentials, signingCallBack, opts) {
        const { holderDID, signatureOptions, proofOptions } = opts;
        const presentationSubmissionLocation = opts.presentationSubmissionLocation ?? PresentationSubmissionLocation.PRESENTATION;
        const updatedOpts = { ...opts, presentationSubmissionLocation };
        function limitedDisclosureSuites() {
            let limitDisclosureSignatureSuites = [];
            if (proofOptions?.typeSupportsSelectiveDisclosure) {
                if (!proofOptions?.type) {
                    throw Error('Please provide a proof type if you enable selective disclosure');
                }
                limitDisclosureSignatureSuites = [proofOptions.type];
            }
            return limitDisclosureSignatureSuites;
        }
        const holderDIDs = holderDID ? [holderDID] : [];
        const limitDisclosureSignatureSuites = limitedDisclosureSuites();
        const evaluationResult = this.evaluateCredentials(presentationDefinition, selectedCredentials, {
            holderDIDs,
            limitDisclosureSignatureSuites,
        });
        const presentationResult = this.presentationFrom(presentationDefinition, evaluationResult.verifiableCredential, updatedOpts);
        const evaluationResults = this.evaluatePresentation(presentationDefinition, presentationResult.presentation, {
            limitDisclosureSignatureSuites,
            ...(presentationSubmissionLocation === PresentationSubmissionLocation.EXTERNAL && {
                // The method will pickup submissions included in the Presentation anyway
                presentationSubmission: presentationResult.presentationSubmission,
            }),
        });
        if (!evaluationResults.value) {
            throw new Error('Could not get evaluation results from presentationResult');
        }
        const proof = {
            type: proofOptions?.type,
            verificationMethod: signatureOptions?.verificationMethod,
            created: proofOptions?.created ? proofOptions.created : new Date().toISOString(),
            proofPurpose: proofOptions?.proofPurpose,
            proofValue: signatureOptions?.proofValue,
            jws: signatureOptions?.jws,
            challenge: proofOptions?.challenge,
            nonce: proofOptions?.nonce,
            domain: proofOptions?.domain,
        };
        const callBackParams = {
            options: updatedOpts,
            presentation: presentationResult.presentation,
            presentationDefinition,
            selectedCredentials,
            proof,
            presentationSubmission: evaluationResults.value,
            evaluationResults,
        };
        const verifiablePresentation = await signingCallBack(callBackParams);
        return {
            verifiablePresentation,
            presentationSubmissionLocation,
            presentationSubmission: evaluationResults.value,
        };
    }
    static definitionVersionDiscovery(presentationDefinition) {
        return definitionVersionDiscovery(presentationDefinition);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUEVYLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vbGliL1BFWC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQ0wsZ0JBQWdCLEdBUWpCLE1BQU0scUJBQXFCLENBQUM7QUFHN0IsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQzNDLE9BQU8sRUFBRSx1QkFBdUIsRUFBb0MsTUFBTSxjQUFjLENBQUM7QUFDekYsT0FBTyxFQUlMLDhCQUE4QixHQUcvQixNQUFNLFdBQVcsQ0FBQztBQUNuQixPQUFPLEVBQStFLFNBQVMsRUFBRSxlQUFlLEVBQUUsTUFBTSxTQUFTLENBQUM7QUFDbEksT0FBTyxFQUFFLDBCQUEwQixFQUFFLHFCQUFxQixFQUFFLE1BQU0sU0FBUyxDQUFDO0FBQzVFLE9BQU8sRUFBRSwwQkFBMEIsRUFBRSwwQkFBMEIsRUFBRSx3QkFBd0IsRUFBYSxnQkFBZ0IsRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUU3STs7R0FFRztBQUNILE1BQU0sT0FBTyxHQUFHO0lBQ0osd0JBQXdCLENBQTBCO0lBRTVEO1FBQ0Usd0tBQXdLO1FBQ3hLLElBQUksQ0FBQyx3QkFBd0IsR0FBRyxJQUFJLHVCQUF1QixFQUFFLENBQUM7SUFDaEUsQ0FBQztJQUVEOzs7Ozs7Ozs7O09BVUc7SUFDSSxvQkFBb0IsQ0FDekIsc0JBQStDLEVBQy9DLFlBQTRELEVBQzVELElBTUM7UUFFRCxNQUFNLDhCQUE4QixHQUNsQyxJQUFJLEVBQUUsOEJBQThCLEtBQUssU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsOEJBQThCLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxzQkFBc0IsS0FBSyxTQUFTLENBQUM7UUFDeEksTUFBTSxFQUFFLEdBQW9DLGVBQWUsQ0FBQyxnQ0FBZ0MsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO1FBQ3JILE1BQU0sZ0JBQWdCLEdBQW1DLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxD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